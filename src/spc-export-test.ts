/**
 * Test file for SPC Export functionality
 * Creates sample SPC files and validates the export process
 */

import * as fs from 'fs';
import * as path from 'path';
import { SPCExporter, SPC700State, DSPState, ID666Metadata } from './spc-exporter';
import { SPCStateExtractor, ExtractedAudioState } from './spc-state-extractor';

export class SPCExportTest {
  /**
   * Run comprehensive tests of SPC export functionality
   */
  public static async runTests(): Promise<void> {
    console.log('üéµ Starting SPC Export Tests...\n');
    
    try {
      // Test 1: Basic SPC file creation
      await this.testBasicSPCCreation();
      
      // Test 2: Metadata handling
      await this.testMetadataHandling();
      
      // Test 3: Extended ID666 support
      await this.testExtendedID666();
      
      // Test 4: File validation
      await this.testFileValidation();
      
      // Test 5: SPC state extraction simulation
      await this.testStateExtraction();
      
      console.log('‚úÖ All SPC export tests passed!');
      
    } catch (error) {
      console.error('‚ùå SPC export test failed:', error);
      throw error;
    }
  }
  
  /**
   * Test basic SPC file creation with minimal data
   */
  private static async testBasicSPCCreation(): Promise<void> {
    console.log('Testing basic SPC file creation...');
    
    // Create basic SPC700 state
    const spcState = SPCExporter.createDefaultSPC700State();
    spcState.pc = 0x0200;
    spcState.a = 0x42;
    spcState.x = 0x12;
    spcState.y = 0x34;
    spcState.psw = 0x02;
    spcState.sp = 0xFF;
    
    // Add some test data to RAM
    spcState.ram[0x0200] = 0xCD; // CMP instruction
    spcState.ram[0x0201] = 0xF4; // Port address
    spcState.ram[0x0202] = 0x00;
    
    // Create basic DSP state
    const dspState = SPCExporter.createDefaultDSPState();
    dspState.mainVolumeLeft = 100;
    dspState.mainVolumeRight = 100;
    
    // Set up a simple voice
    dspState.voices[0].volumeLeft = 127;
    dspState.voices[0].volumeRight = 127;
    dspState.voices[0].pitch = 0x1000;
    
    // Create basic metadata
    const metadata: ID666Metadata = {
      songTitle: 'Test Song',
      gameTitle: 'Test Game',
      dumperName: 'SPC Test',
      comments: 'Generated by SPC Export Test',
      playTime: 60,
      fadeLength: 3000
    };
    
    // Export SPC file
    const spcData = SPCExporter.exportSPC(spcState, dspState, metadata);
    
    // Verify file size (should be at least 66048 bytes)
    if (spcData.length < 66048) {
      throw new Error(`SPC file too small: ${spcData.length} bytes`);
    }
    
    // Save test file
    const outputPath = path.join('output', 'test_basic.spc');
    await this.ensureOutputDir();
    fs.writeFileSync(outputPath, spcData);
    
    console.log(`‚úì Basic SPC file created: ${outputPath} (${spcData.length} bytes)`);
  }
  
  /**
   * Test metadata handling with various formats
   */
  private static async testMetadataHandling(): Promise<void> {
    console.log('Testing metadata handling...');
    
    const spcState = SPCExporter.createDefaultSPC700State();
    const dspState = SPCExporter.createDefaultDSPState();
    
    // Test with comprehensive metadata
    const metadata: ID666Metadata = {
      songTitle: 'The Legend of Zelda - Overworld',
      gameTitle: 'The Legend of Zelda: A Link to the Past',
      dumperName: 'SNES Disassembler',
      comments: 'Extracted from ROM analysis',
      dumpDate: '12/25/2024',
      playTime: 180,
      fadeLength: 5000,
      artist: 'Koji Kondo',
      defaultChannelDisables: 0x00,
      emulator: 2, // Snes9x
      publisher: 'Nintendo',
      year: 1991,
      genre: 'Video Game Music'
    };
    
    // Test text format
    const textSPC = SPCExporter.exportSPC(spcState, dspState, metadata, {
      includeID666: true,
      binaryFormat: false
    });
    
    // Test binary format
    const binarySPC = SPCExporter.exportSPC(spcState, dspState, metadata, {
      includeID666: true,
      binaryFormat: true
    });
    
    // Save both formats
    const textPath = path.join('output', 'test_text_metadata.spc');
    const binaryPath = path.join('output', 'test_binary_metadata.spc');
    
    fs.writeFileSync(textPath, textSPC);
    fs.writeFileSync(binaryPath, binarySPC);
    
    console.log(`‚úì Text format metadata SPC: ${textPath} (${textSPC.length} bytes)`);
    console.log(`‚úì Binary format metadata SPC: ${binaryPath} (${binarySPC.length} bytes)`);
  }
  
  /**
   * Test extended ID666 (xid6) functionality
   */
  private static async testExtendedID666(): Promise<void> {
    console.log('Testing extended ID666 support...');
    
    const spcState = SPCExporter.createDefaultSPC700State();
    const dspState = SPCExporter.createDefaultDSPState();
    
    const metadata: ID666Metadata = {
      songTitle: 'Super Metroid - Brinstar',
      gameTitle: 'Super Metroid',
      dumperName: 'Advanced Tester',
      publisher: 'Nintendo',
      year: 1994,
      genre: 'Sci-Fi/Action',
      originalSoundtrack: 'Super Metroid OST',
      introduction: 5000,  // 5 second intro
      loop: 120000,        // 2 minute loop
      ending: 8000,        // 8 second ending
      mixing: 75,          // 75% mixing level
      preamp: 85           // 85% preamp
    };
    
    const extendedSPC = SPCExporter.exportSPC(spcState, dspState, metadata, {
      includeID666: true,
      includeExtended: true,
      binaryFormat: false
    });
    
    const extendedPath = path.join('output', 'test_extended_id666.spc');
    fs.writeFileSync(extendedPath, extendedSPC);
    
    console.log(`‚úì Extended ID666 SPC: ${extendedPath} (${extendedSPC.length} bytes)`);
  }
  
  /**
   * Test file validation
   */
  private static async testFileValidation(): Promise<void> {
    console.log('Testing file validation...');
    
    const spcState = SPCExporter.createDefaultSPC700State();
    const dspState = SPCExporter.createDefaultDSPState();
    
    // Test with validation enabled (default)
    try {
      const validSPC = SPCExporter.exportSPC(spcState, dspState, undefined, {
        validate: true
      });
      console.log('‚úì File validation passed');
    } catch (error) {
      throw new Error(`File validation should have passed: ${error}`);
    }
    
    // Test with validation disabled
    const unvalidatedSPC = SPCExporter.exportSPC(spcState, dspState, undefined, {
      validate: false
    });
    
    console.log('‚úì Validation bypass works');
  }
  
  /**
   * Test SPC state extraction simulation
   */
  private static async testStateExtraction(): Promise<void> {
    console.log('Testing SPC state extraction simulation...');
    
    // Create mock disassembly data that simulates SPC upload code
    const mockLines = this.createMockDisassemblyLines();
    const mockROMData = this.createMockROMData();
    const mockCartridgeInfo = {
      title: 'Test Game for SPC Export',
      publisherCode: 'TEST',
      region: 'NTSC',
      version: 1
    };
    
    // Extract audio state
    const extractedState = SPCStateExtractor.extractAudioState(
      mockLines,
      mockROMData,
      mockCartridgeInfo as any
    );
    
    console.log(`‚úì Found ${extractedState.spcUploads.length} SPC upload sequences`);
    console.log(`‚úì Found ${extractedState.brrSamples.length} BRR samples`);
    console.log(`‚úì Found ${extractedState.musicSequences.length} music sequences`);
    console.log(`‚úì Found ${extractedState.audioData.length} audio data locations`);
    
    // Convert extracted state to complete states for export
    const completeSPCState: SPC700State = {
      pc: extractedState.spc700State.pc || 0x0200,
      a: extractedState.spc700State.a || 0,
      x: extractedState.spc700State.x || 0,
      y: extractedState.spc700State.y || 0,
      psw: extractedState.spc700State.psw || 0x02,
      sp: extractedState.spc700State.sp || 0xFF,
      ram: extractedState.spc700State.ram || new Uint8Array(0x10000),
      timer0: extractedState.spc700State.timer0 || { value: 0, target: 0, enabled: false },
      timer1: extractedState.spc700State.timer1 || { value: 0, target: 0, enabled: false },
      timer2: extractedState.spc700State.timer2 || { value: 0, target: 0, enabled: false },
      ports: extractedState.spc700State.ports || {
        cpuToApu: new Uint8Array(4),
        apuToCpu: new Uint8Array(4)
      }
    };
    
    const completeDSPState: DSPState = {
      registers: extractedState.dspState.registers || new Uint8Array(128),
      voices: extractedState.dspState.voices || Array.from({ length: 8 }, () => ({
        volumeLeft: 0, volumeRight: 0, pitch: 0x1000, sourceNumber: 0,
        adsr1: 0, adsr2: 0, gain: 0, envx: 0, outx: 0
      })),
      mainVolumeLeft: extractedState.dspState.mainVolumeLeft || 127,
      mainVolumeRight: extractedState.dspState.mainVolumeRight || 127,
      echoVolumeLeft: extractedState.dspState.echoVolumeLeft || 0,
      echoVolumeRight: extractedState.dspState.echoVolumeRight || 0,
      keyOn: extractedState.dspState.keyOn || 0,
      keyOff: extractedState.dspState.keyOff || 0,
      flg: extractedState.dspState.flg || 0x20,
      endx: extractedState.dspState.endx || 0,
      efb: extractedState.dspState.efb || 0,
      pmon: extractedState.dspState.pmon || 0,
      non: extractedState.dspState.non || 0,
      eon: extractedState.dspState.eon || 0,
      dir: extractedState.dspState.dir || 0,
      esa: extractedState.dspState.esa || 0,
      edl: extractedState.dspState.edl || 0
    };
    
    // Export the extracted state as an SPC file
    const extractedSPC = SPCExporter.exportSPC(
      completeSPCState,
      completeDSPState,
      extractedState.metadata as ID666Metadata
    );
    
    const extractedPath = path.join('output', 'test_extracted_state.spc');
    fs.writeFileSync(extractedPath, extractedSPC);
    
    console.log(`‚úì Extracted state SPC: ${extractedPath} (${extractedSPC.length} bytes)`);
  }
  
  /**
   * Create mock disassembly lines for testing
   */
  private static createMockDisassemblyLines(): any[] {
    return [
      {
        address: 0x8000,
        bytes: [0xA9, 0xCC],
        instruction: { mnemonic: 'LDA', addressingMode: '#' },
        operand: 0xCC
      },
      {
        address: 0x8002,
        bytes: [0x8D, 0x41, 0x21],
        instruction: { mnemonic: 'STA', addressingMode: 'abs' },
        operand: 0x2141
      },
      {
        address: 0x8005,
        bytes: [0xA9, 0xBB],
        instruction: { mnemonic: 'LDA', addressingMode: '#' },
        operand: 0xBB
      },
      {
        address: 0x8007,
        bytes: [0x8D, 0x40, 0x21],
        instruction: { mnemonic: 'STA', addressingMode: 'abs' },
        operand: 0x2140
      },
      {
        address: 0x800A,
        bytes: [0xAD, 0x40, 0x21],
        instruction: { mnemonic: 'LDA', addressingMode: 'abs' },
        operand: 0x2140
      },
      {
        address: 0x800D,
        bytes: [0xC9, 0xCC],
        instruction: { mnemonic: 'CMP', addressingMode: '#' },
        operand: 0xCC
      },
      {
        address: 0x800F,
        bytes: [0xD0, 0xF9],
        instruction: { mnemonic: 'BNE', addressingMode: 'rel' },
        operand: 0x800A
      }
    ];
  }
  
  /**
   * Create mock ROM data with audio patterns
   */
  private static createMockROMData(): Uint8Array {
    const romData = new Uint8Array(0x80000); // 512KB ROM
    
    // Add mock BRR sample at offset 0x10000
    romData[0x10000] = 0x0C; // BRR header: range 0, filter 3
    for (let i = 1; i < 9; i++) {
      romData[0x10000 + i] = i * 0x11; // Sample data pattern
    }
    
    // Add end block
    romData[0x10009] = 0x01; // End flag set
    for (let i = 1; i < 9; i++) {
      romData[0x10009 + i] = 0x00; // Silent end
    }
    
    // Add mock music data at 0x20000
    romData[0x20000] = 0x60; // Tempo
    romData[0x20001] = 0x04; // 4 tracks
    romData[0x20002] = 0xFF; // Channel mask
    
    // Add mock sample directory at 0x30000
    for (let i = 0; i < 64; i += 4) {
      romData[0x30000 + i] = (0x1000 + i * 64) & 0xFF;     // Start addr low
      romData[0x30000 + i + 1] = ((0x1000 + i * 64) >> 8) & 0xFF; // Start addr high
      romData[0x30000 + i + 2] = (0x1000 + i * 64) & 0xFF;     // Loop addr low
      romData[0x30000 + i + 3] = ((0x1000 + i * 64) >> 8) & 0xFF; // Loop addr high
    }
    
    return romData;
  }
  
  /**
   * Ensure output directory exists
   */
  private static async ensureOutputDir(): Promise<void> {
    const outputDir = 'output';
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }
  }
}

// Export for CLI usage
export default SPCExportTest;
